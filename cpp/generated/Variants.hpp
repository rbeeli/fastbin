#pragma once

#include <cstddef>
#include <cstring>
#include <cassert>
#include <ostream>
#include <span>
#include "_traits.hpp"
#include "_BufferStored.hpp"
#include "Variant.hpp"

namespace my_models
{
/**
 * Binary serializable data container generated by `fastbin`.
 * 
 * This container has variable size.
 * All setter methods starting from the first variable-sized member and afterwards MUST be called in order.
 *
 * Members in order
 * ================
 * - `primitives` [`Variant<std::int32_t, std::int64_t, std::uint8_t>`] (variable)
 * - `primitives_and_string` [`Variant<std::string_view, double, bool>`] (variable)
 * - `structs` [`Variant<ChildFixed, ChildVar>`] (variable)
 *
 * The `finalize()` method MUST be called after all setter methods have been called.
 * 
 * It is the responsibility of the caller to ensure that the buffer is
 * large enough to hold all data.
 */
class Variants final : public BufferStored<Variants>
{
public:
    using BufferStored<Variants>::buffer;
    using BufferStored<Variants>::buffer_size;
    using BufferStored<Variants>::owns_buffer;

protected:
    friend class BufferStored<Variants>;

    Variants(
        std::byte* buffer, size_t buffer_size, bool owns_buffer
    ) noexcept
        : BufferStored<Variants>(buffer, buffer_size, owns_buffer)
    {
    }

public:
    static Variants create(std::byte* buffer, size_t buffer_size, bool owns_buffer) noexcept
    {
        std::memset(buffer, 0, buffer_size);
        return {buffer, buffer_size, owns_buffer};
    }
    
    // disable copy
    Variants(const Variants&) = delete;
    Variants& operator=(const Variants&) = delete;

    // inherit move
    Variants(Variants&&) noexcept = default;
    Variants& operator=(Variants&&) noexcept = default;


    // Member: primitives [Variant<std::int32_t, std::int64_t, std::uint8_t>]

    inline Variant<std::int32_t, std::int64_t, std::uint8_t> primitives() const noexcept
    {
        size_t offset = _primitives_offset();
        size_t aligned_size_high = *reinterpret_cast<size_t*>(buffer + offset);
        size_t aligned_size = aligned_size_high & 0x00FFFFFFFFFFFFFF;
        size_t aligned_diff = aligned_size_high >> 56;
        auto ptr = buffer + offset + 8;
        return Variant<std::int32_t, std::int64_t, std::uint8_t>::open(ptr, aligned_size - aligned_diff, false);
    }

    inline void primitives(const Variant<std::int32_t, std::int64_t, std::uint8_t>& value) noexcept
    {
        assert(value.fastbin_binary_size() > 0 && "Cannot set member `primitives`, parameter of Variant type `Variant<std::int32_t, std::int64_t, std::uint8_t>` not initialized.");
        size_t offset = _primitives_offset();
        size_t contents_size = value.fastbin_binary_size();
        size_t unaligned_size = 8 + contents_size;
        size_t aligned_size = (unaligned_size + 7) & ~7;
        size_t aligned_diff = aligned_size - unaligned_size;
        size_t aligned_size_high = aligned_size | (aligned_diff << 56);
        *reinterpret_cast<size_t*>(buffer + offset) = aligned_size_high;
        auto dest_ptr = buffer + offset + 8;
        std::copy(value.buffer, value.buffer + contents_size, dest_ptr);
    }

    constexpr inline size_t _primitives_offset() const noexcept
    {
        return 8;
    }

    constexpr inline size_t _primitives_size_aligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _primitives_offset());
        size_t aligned_size = stored_size & 0x00FFFFFFFFFFFFFF;
        return aligned_size;
    }

    static size_t _primitives_calc_size_aligned(const Variant<std::int32_t, std::int64_t, std::uint8_t>& value)
    {
        size_t unaligned_size = 8 + value.fastbin_binary_size();
        size_t aligned_size = (unaligned_size + 7) & ~7;
        return aligned_size;
    }


    // Member: primitives_and_string [Variant<std::string_view, double, bool>]

    inline Variant<std::string_view, double, bool> primitives_and_string() const noexcept
    {
        size_t offset = _primitives_and_string_offset();
        size_t aligned_size_high = *reinterpret_cast<size_t*>(buffer + offset);
        size_t aligned_size = aligned_size_high & 0x00FFFFFFFFFFFFFF;
        size_t aligned_diff = aligned_size_high >> 56;
        auto ptr = buffer + offset + 8;
        return Variant<std::string_view, double, bool>::open(ptr, aligned_size - aligned_diff, false);
    }

    inline void primitives_and_string(const Variant<std::string_view, double, bool>& value) noexcept
    {
        assert(value.fastbin_binary_size() > 0 && "Cannot set member `primitives_and_string`, parameter of Variant type `Variant<std::string_view, double, bool>` not initialized.");
        size_t offset = _primitives_and_string_offset();
        size_t contents_size = value.fastbin_binary_size();
        size_t unaligned_size = 8 + contents_size;
        size_t aligned_size = (unaligned_size + 7) & ~7;
        size_t aligned_diff = aligned_size - unaligned_size;
        size_t aligned_size_high = aligned_size | (aligned_diff << 56);
        *reinterpret_cast<size_t*>(buffer + offset) = aligned_size_high;
        auto dest_ptr = buffer + offset + 8;
        std::copy(value.buffer, value.buffer + contents_size, dest_ptr);
    }

    constexpr inline size_t _primitives_and_string_offset() const noexcept
    {
        return _primitives_offset() + _primitives_size_aligned();
    }

    constexpr inline size_t _primitives_and_string_size_aligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _primitives_and_string_offset());
        size_t aligned_size = stored_size & 0x00FFFFFFFFFFFFFF;
        return aligned_size;
    }

    static size_t _primitives_and_string_calc_size_aligned(const Variant<std::string_view, double, bool>& value)
    {
        size_t unaligned_size = 8 + value.fastbin_binary_size();
        size_t aligned_size = (unaligned_size + 7) & ~7;
        return aligned_size;
    }


    // Member: structs [Variant<ChildFixed, ChildVar>]

    inline Variant<ChildFixed, ChildVar> structs() const noexcept
    {
        size_t offset = _structs_offset();
        size_t aligned_size_high = *reinterpret_cast<size_t*>(buffer + offset);
        size_t aligned_size = aligned_size_high & 0x00FFFFFFFFFFFFFF;
        size_t aligned_diff = aligned_size_high >> 56;
        auto ptr = buffer + offset + 8;
        return Variant<ChildFixed, ChildVar>::open(ptr, aligned_size - aligned_diff, false);
    }

    inline void structs(const Variant<ChildFixed, ChildVar>& value) noexcept
    {
        assert(value.fastbin_binary_size() > 0 && "Cannot set member `structs`, parameter of Variant type `Variant<ChildFixed, ChildVar>` not initialized.");
        size_t offset = _structs_offset();
        size_t contents_size = value.fastbin_binary_size();
        size_t unaligned_size = 8 + contents_size;
        size_t aligned_size = (unaligned_size + 7) & ~7;
        size_t aligned_diff = aligned_size - unaligned_size;
        size_t aligned_size_high = aligned_size | (aligned_diff << 56);
        *reinterpret_cast<size_t*>(buffer + offset) = aligned_size_high;
        auto dest_ptr = buffer + offset + 8;
        std::copy(value.buffer, value.buffer + contents_size, dest_ptr);
    }

    constexpr inline size_t _structs_offset() const noexcept
    {
        return _primitives_and_string_offset() + _primitives_and_string_size_aligned();
    }

    constexpr inline size_t _structs_size_aligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _structs_offset());
        size_t aligned_size = stored_size & 0x00FFFFFFFFFFFFFF;
        return aligned_size;
    }

    static size_t _structs_calc_size_aligned(const Variant<ChildFixed, ChildVar>& value)
    {
        size_t unaligned_size = 8 + value.fastbin_binary_size();
        size_t aligned_size = (unaligned_size + 7) & ~7;
        return aligned_size;
    }


    // --------------------------------------------------------------------------------

    constexpr inline size_t fastbin_calc_binary_size() const noexcept
    {
        return _structs_offset() + _structs_size_aligned();
    }

    static size_t fastbin_calc_binary_size(
        const Variant<std::int32_t, std::int64_t, std::uint8_t>& primitives,
        const Variant<std::string_view, double, bool>& primitives_and_string,
        const Variant<ChildFixed, ChildVar>& structs
    )
    {
        return 8 + _primitives_calc_size_aligned(primitives) +
            _primitives_and_string_calc_size_aligned(primitives_and_string) +
            _structs_calc_size_aligned(structs);
    }

    /**
     * Returns the stored (aligned) binary size of the object.
     * This function should only be called after `fastbin_finalize()`.
     */
    constexpr inline size_t fastbin_binary_size() const noexcept
    {
        return *reinterpret_cast<size_t*>(buffer);
    }

    /**
     * Finalizes the object by writing the binary size to the beginning of its buffer.
     * After calling this function, the underlying buffer can be used for serialization.
     * To get the actual buffer size, call `fastbin_binary_size()`.
     */
    inline void fastbin_finalize() noexcept
    {
        *reinterpret_cast<size_t*>(buffer) = fastbin_calc_binary_size();
    }
};

// Type traits
template <>
struct is_variable_size<Variants> : std::true_type {};

template <>
struct is_buffer_stored<Variants> : std::true_type {};
}; // namespace my_models

inline std::ostream& operator<<(std::ostream& os, const my_models::Variants& obj)
{
    os << "[my_models::Variants size=" << obj.fastbin_binary_size() << " bytes]\n";
    os << "    primitives: " << "[Variant<int32, int64, uint8> index=" << obj.primitives().index() << "]" << "\n";
    os << "    primitives_and_string: " << "[Variant<string, float64, bool> index=" << obj.primitives_and_string().index() << "]" << "\n";
    os << "    structs: " << "[Variant<struct:ChildFixed, struct:ChildVar> index=" << obj.structs().index() << "]" << "\n";
    return os;
}
