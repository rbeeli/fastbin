#pragma once

#include <cstddef>
#include <cstring>
#include <cassert>
#include <ostream>
#include <span>
#include <string_view>
#include "_traits.hpp"
#include "_helpers.hpp"
#include "_BufferStored.hpp"
#include "StructArray.hpp"

namespace my_models
{
/**
 * Binary serializable data container generated by `fastbin`.
 * 
 * This container has variable size.
 * All setter methods starting from the first variable-sized member and afterwards MUST be called in order.
 *
 * Members in order
 * ================
 * - `values` [`StructArray<ChildFixed>`] (variable)
 * - `str` [`std::string_view`] (variable)
 *
 * The `finalize()` method MUST be called after all setter methods have been called.
 * 
 * It is the responsibility of the caller to ensure that the buffer is
 * large enough to hold all data.
 */
class VectorOfFixedSizedStructs final : public BufferStored<VectorOfFixedSizedStructs>
{
public:
    using BufferStored<VectorOfFixedSizedStructs>::buffer;
    using BufferStored<VectorOfFixedSizedStructs>::buffer_size;
    using BufferStored<VectorOfFixedSizedStructs>::owns_buffer;

protected:
    friend class BufferStored<VectorOfFixedSizedStructs>;

    VectorOfFixedSizedStructs(
        std::byte* buffer, size_t buffer_size, bool owns_buffer
    ) noexcept
        : BufferStored<VectorOfFixedSizedStructs>(buffer, buffer_size, owns_buffer)
    {
    }

public:
    static VectorOfFixedSizedStructs create(std::byte* buffer, size_t buffer_size, bool owns_buffer) noexcept
    {
        std::memset(buffer, 0, buffer_size);
        return {buffer, buffer_size, owns_buffer};
    }
    
    // disable copy
    VectorOfFixedSizedStructs(const VectorOfFixedSizedStructs&) = delete;
    VectorOfFixedSizedStructs& operator=(const VectorOfFixedSizedStructs&) = delete;

    // inherit move
    VectorOfFixedSizedStructs(VectorOfFixedSizedStructs&&) noexcept = default;
    VectorOfFixedSizedStructs& operator=(VectorOfFixedSizedStructs&&) noexcept = default;


    // Member: values [StructArray<ChildFixed>]

    inline StructArray<ChildFixed> values() const noexcept
    {
        auto ptr = buffer + _values_offset();
        return StructArray<ChildFixed>::open(ptr, _values_size_unaligned(), false);
    }

    inline void values(const StructArray<ChildFixed>& value) noexcept
    {
        assert(value.fastbin_binary_size() > 0 && "Cannot set member `values`. Parameter of type `StructArray<ChildFixed>` not initialized.");
        auto dest_ptr = buffer + _values_offset();
        size_t size = value.fastbin_binary_size();
        std::copy(value.buffer, value.buffer + size, dest_ptr);
    }

    constexpr inline size_t _values_offset() const noexcept
    {
        return 8;
    }

    constexpr inline size_t _values_size_aligned() const noexcept
    {
        size_t stored_size = load_trivial<size_t>(buffer, _values_offset());
        return stored_size;
    }

    static size_t _values_calc_size_aligned(const StructArray<ChildFixed>& value) noexcept
    {
        return value.fastbin_binary_size();
    }

    constexpr inline size_t _values_size_unaligned() const noexcept
    {
        size_t stored_size = load_trivial<size_t>(buffer, _values_offset());
        return stored_size;
    }

    // Member: str [std::string_view]

    inline std::string_view str() const noexcept
    {
        size_t n_bytes = _str_size_unaligned() - 8;
        auto ptr = reinterpret_cast<const char*>(buffer + _str_offset() + 8);
        return std::string_view(ptr, n_bytes);
    }

    inline void str(const std::string_view value) noexcept
    {
        size_t offset = _str_offset();
        size_t contents_size = value.size() * 1;
        size_t unaligned_size = 8 + contents_size;
        size_t aligned_size = (unaligned_size + 7) & ~7;
        size_t aligned_diff = aligned_size - unaligned_size;
        size_t aligned_size_high = aligned_size | (aligned_diff << 56);
        store_trivial<size_t>(buffer, offset, aligned_size_high);
        auto dest_ptr = reinterpret_cast<std::byte*>(buffer + offset + 8);
        auto src_ptr = reinterpret_cast<const std::byte*>(value.data());
        std::copy(src_ptr, src_ptr + contents_size, dest_ptr);
    }

    constexpr inline size_t _str_offset() const noexcept
    {
        return _values_offset() + _values_size_aligned();
    }

    constexpr inline size_t _str_size_aligned() const noexcept
    {
        size_t stored_size = load_trivial<size_t>(buffer, _str_offset());
        size_t aligned_size = stored_size & 0x00FFFFFFFFFFFFFF;
        return aligned_size;
    }

    static size_t _str_calc_size_aligned(const std::string_view& value) noexcept
    {
        size_t contents_size = value.size() * 1;
        size_t unaligned_size = 8 + contents_size;
        return (unaligned_size + 7) & ~7;
    }

    constexpr inline size_t _str_size_unaligned() const noexcept
    {
        size_t stored_size = load_trivial<size_t>(buffer, _str_offset());
        size_t aligned_size = stored_size & 0x00FFFFFFFFFFFFFF;
        size_t aligned_diff = stored_size >> 56;
        return aligned_size - aligned_diff;
    }

    // --------------------------------------------------------------------------------

    constexpr inline size_t fastbin_calc_binary_size() const noexcept
    {
        return _str_offset() + _str_size_aligned();
    }

    static size_t fastbin_calc_binary_size(
        const StructArray<ChildFixed>& values,
        const std::string_view& str
    ) noexcept
    {
        return 8 + _values_calc_size_aligned(values) +
            _str_calc_size_aligned(str);
    }

    /**
     * Returns the stored (aligned) binary size of the object.
     * This function should only be called after `fastbin_finalize()`.
     */
    constexpr inline size_t fastbin_binary_size() const noexcept
    {
        return load_trivial<size_t>(buffer, 0);
    }

    /**
     * Finalizes the object by writing the binary size to the beginning of its buffer.
     * After calling this function, the underlying buffer can be used for serialization.
     * To get the actual buffer size, call `fastbin_binary_size()`.
     */
    inline void fastbin_finalize() noexcept
    {
        store_trivial<size_t>(buffer, 0, fastbin_calc_binary_size());
    }
};

// Type traits
template <>
struct is_variable_size<VectorOfFixedSizedStructs> : std::true_type {};

template <>
struct is_buffer_stored<VectorOfFixedSizedStructs> : std::true_type {};
}; // namespace my_models

inline std::ostream& operator<<(std::ostream& os, const my_models::VectorOfFixedSizedStructs& obj)
{
    os << "[my_models::VectorOfFixedSizedStructs size=" << obj.fastbin_binary_size() << " bytes]\n";
    os << "    values: " << "[vector<struct:ChildFixed> count=" << obj.values().size() << "]" << "\n";
    os << "    str: " << std::string(obj.str()) << "\n";
    return os;
}
