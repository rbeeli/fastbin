#pragma once

#include <cstddef>
#include <cstring>
#include <cassert>
#include <ostream>
#include <span>
#include <cstdint>
#include "_traits.hpp"
#include "_BufferStored.hpp"

namespace my_models
{
/**
 * Binary serializable data container generated by `fastbin`.
 * 
 * This container has fixed size of 16 bytes.
 *
 * Members in order
 * ================
 * - `field1` [`std::int32_t`] (fixed)
 * - `field2` [`std::int32_t`] (fixed)
 *
 * The `finalize()` method MUST be called after all setter methods have been called.
 * 
 * It is the responsibility of the caller to ensure that the buffer is
 * large enough to hold all data.
 */
class ChildFixed final : public BufferStored<ChildFixed>
{
public:
    using BufferStored<ChildFixed>::buffer;
    using BufferStored<ChildFixed>::buffer_size;
    using BufferStored<ChildFixed>::owns_buffer;

protected:
    friend class BufferStored<ChildFixed>;

    ChildFixed(
        std::byte* buffer, size_t buffer_size, bool owns_buffer
    ) noexcept
        : BufferStored<ChildFixed>(buffer, buffer_size, owns_buffer)
    {
    }

public:
    static ChildFixed create(std::byte* buffer, size_t buffer_size, bool owns_buffer) noexcept
    {
        std::memset(buffer, 0, buffer_size);
        return {buffer, buffer_size, owns_buffer};
    }
    
    // disable copy
    ChildFixed(const ChildFixed&) = delete;
    ChildFixed& operator=(const ChildFixed&) = delete;

    // inherit move
    ChildFixed(ChildFixed&&) noexcept = default;
    ChildFixed& operator=(ChildFixed&&) noexcept = default;


    // Member: field1 [std::int32_t]

    inline std::int32_t field1() const noexcept
    {
        return *reinterpret_cast<const std::int32_t*>(buffer + _field1_offset());
    }

    inline void field1(const std::int32_t value) noexcept
    {
        *reinterpret_cast<std::int32_t*>(buffer + _field1_offset()) = value;
    }

    constexpr inline size_t _field1_offset() const noexcept
    {
        return 0;
    }

    constexpr inline size_t _field1_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _field1_calc_size_aligned(const std::int32_t& value)
    {
        return 8;
    }


    // Member: field2 [std::int32_t]

    inline std::int32_t field2() const noexcept
    {
        return *reinterpret_cast<const std::int32_t*>(buffer + _field2_offset());
    }

    inline void field2(const std::int32_t value) noexcept
    {
        *reinterpret_cast<std::int32_t*>(buffer + _field2_offset()) = value;
    }

    constexpr inline size_t _field2_offset() const noexcept
    {
        return 8;
    }

    constexpr inline size_t _field2_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _field2_calc_size_aligned(const std::int32_t& value)
    {
        return 8;
    }


    // --------------------------------------------------------------------------------

    constexpr inline size_t fastbin_calc_binary_size() const noexcept
    {
        return 16;
    }

    constexpr size_t fastbin_calc_binary_size()
    {
        return 16;
    }

    /**
     * Returns the stored (aligned) binary size of the object.
     * This function should only be called after `fastbin_finalize()`.
     */
    constexpr inline size_t fastbin_binary_size() const noexcept
    {
        return 16;
    }

    static constexpr size_t fastbin_fixed_size() noexcept
    {
        return 16;
    }

    /**
     * Finalizes the object by writing the binary size to the beginning of its buffer.
     * After calling this function, the underlying buffer can be used for serialization.
     * To get the actual buffer size, call `fastbin_binary_size()`.
     */
    inline void fastbin_finalize() noexcept
    {
    }
};

// Type traits
template <>
struct is_variable_size<ChildFixed> : std::false_type {};

template <>
struct is_buffer_stored<ChildFixed> : std::true_type {};
}; // namespace my_models

inline std::ostream& operator<<(std::ostream& os, const my_models::ChildFixed& obj)
{
    os << "[my_models::ChildFixed size=" << obj.fastbin_binary_size() << " bytes]\n";
    os << "    field1: " << obj.field1() << "\n";
    os << "    field2: " << obj.field2() << "\n";
    return os;
}
