#pragma once

#include <cstddef>
#include <cstring>
#include <cassert>
#include <ostream>
#include <span>
#include <cstdint>
#include <string_view>
#include "_traits.hpp"
#include "_BufferStored.hpp"
#include "OrderbookType.hpp"

namespace my_models
{
/**
 * https://bybit-exchange.github.io/docs/v5/websocket/public/orderbook
 *
 * ------------------------------------------------------------
 *
 * Binary serializable data container generated by `fastbin`.
 * 
 * This container has variable size.
 * All setter methods starting from the first variable-sized member and afterwards MUST be called in order.
 *
 * Members in order
 * ================
 * - `server_time` [`std::int64_t`] (fixed)
 * - `recv_time` [`std::int64_t`] (fixed)
 * - `cts` [`std::int64_t`]   (fixed)
 * - `type` [`OrderbookType`] (fixed)
 * - `depth` [`std::uint16_t`] (fixed)
 * - `symbol` [`std::string_view`] (variable)
 * - `update_id` [`std::uint64_t`] (fixed)
 * - `seq_num` [`std::uint64_t`] (fixed)
 * - `bid_prices` [`std::span<double>`] (variable)
 * - `bid_quantities` [`std::span<double>`] (variable)
 * - `ask_prices` [`std::span<double>`] (variable)
 * - `ask_quantities` [`std::span<double>`] (variable)
 *
 * The `finalize()` method MUST be called after all setter methods have been called.
 * 
 * It is the responsibility of the caller to ensure that the buffer is
 * large enough to hold all data.
 */
class StreamOrderbook final : public BufferStored<StreamOrderbook>
{
public:
    using BufferStored<StreamOrderbook>::buffer;
    using BufferStored<StreamOrderbook>::buffer_size;
    using BufferStored<StreamOrderbook>::owns_buffer;

protected:
    friend class BufferStored<StreamOrderbook>;

    StreamOrderbook(
        std::byte* buffer, size_t buffer_size, bool owns_buffer
    ) noexcept
        : BufferStored<StreamOrderbook>(buffer, buffer_size, owns_buffer)
    {
    }

public:
    static StreamOrderbook create(std::byte* buffer, size_t buffer_size, bool owns_buffer) noexcept
    {
        std::memset(buffer, 0, buffer_size);
        return {buffer, buffer_size, owns_buffer};
    }
    
    // disable copy
    StreamOrderbook(const StreamOrderbook&) = delete;
    StreamOrderbook& operator=(const StreamOrderbook&) = delete;

    // inherit move
    StreamOrderbook(StreamOrderbook&&) noexcept = default;
    StreamOrderbook& operator=(StreamOrderbook&&) noexcept = default;


    // Member: server_time [std::int64_t]

    inline std::int64_t server_time() const noexcept
    {
        return *reinterpret_cast<const std::int64_t*>(buffer + _server_time_offset());
    }

    inline void server_time(const std::int64_t value) noexcept
    {
        *reinterpret_cast<std::int64_t*>(buffer + _server_time_offset()) = value;
    }

    constexpr inline size_t _server_time_offset() const noexcept
    {
        return 8;
    }

    constexpr inline size_t _server_time_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _server_time_calc_size_aligned(const std::int64_t& value)
    {
        return 8;
    }


    // Member: recv_time [std::int64_t]

    inline std::int64_t recv_time() const noexcept
    {
        return *reinterpret_cast<const std::int64_t*>(buffer + _recv_time_offset());
    }

    inline void recv_time(const std::int64_t value) noexcept
    {
        *reinterpret_cast<std::int64_t*>(buffer + _recv_time_offset()) = value;
    }

    constexpr inline size_t _recv_time_offset() const noexcept
    {
        return 16;
    }

    constexpr inline size_t _recv_time_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _recv_time_calc_size_aligned(const std::int64_t& value)
    {
        return 8;
    }


    // Member: cts [std::int64_t]

    inline std::int64_t cts() const noexcept
    {
        return *reinterpret_cast<const std::int64_t*>(buffer + _cts_offset());
    }

    inline void cts(const std::int64_t value) noexcept
    {
        *reinterpret_cast<std::int64_t*>(buffer + _cts_offset()) = value;
    }

    constexpr inline size_t _cts_offset() const noexcept
    {
        return 24;
    }

    constexpr inline size_t _cts_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _cts_calc_size_aligned(const std::int64_t& value)
    {
        return 8;
    }


    // Member: type [OrderbookType]

    inline OrderbookType type() const noexcept
    {
        return static_cast<OrderbookType>(*reinterpret_cast<const OrderbookType*>(buffer + _type_offset()));
    }

    inline void type(const OrderbookType value) noexcept
    {
        *reinterpret_cast<OrderbookType*>(buffer + _type_offset()) = static_cast<OrderbookType>(value);
    }

    constexpr inline size_t _type_offset() const noexcept
    {
        return 32;
    }

    constexpr inline size_t _type_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _type_calc_size_aligned(const OrderbookType& value)
    {
        return 8;
    }


    // Member: depth [std::uint16_t]

    inline std::uint16_t depth() const noexcept
    {
        return *reinterpret_cast<const std::uint16_t*>(buffer + _depth_offset());
    }

    inline void depth(const std::uint16_t value) noexcept
    {
        *reinterpret_cast<std::uint16_t*>(buffer + _depth_offset()) = value;
    }

    constexpr inline size_t _depth_offset() const noexcept
    {
        return 40;
    }

    constexpr inline size_t _depth_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _depth_calc_size_aligned(const std::uint16_t& value)
    {
        return 8;
    }


    // Member: symbol [std::string_view]

    inline std::string_view symbol() const noexcept
    {
        size_t n_bytes = _symbol_size_unaligned() - 8;
        auto ptr = reinterpret_cast<const char*>(buffer + _symbol_offset() + 8);
        return std::string_view(ptr, n_bytes);
    }

    inline void symbol(const std::string_view value) noexcept
    {
        size_t offset = _symbol_offset();
        size_t contents_size = value.size() * 1;
        size_t unaligned_size = 8 + contents_size;
        size_t aligned_size = (unaligned_size + 7) & ~7;
        size_t aligned_diff = aligned_size - unaligned_size;
        size_t aligned_size_high = aligned_size | (aligned_diff << 56);
        *reinterpret_cast<size_t*>(buffer + offset) = aligned_size_high;
        auto dest_ptr = reinterpret_cast<std::byte*>(buffer + offset + 8);
        auto src_ptr = reinterpret_cast<const std::byte*>(value.data());
        std::copy(src_ptr, src_ptr + contents_size, dest_ptr);
    }

    constexpr inline size_t _symbol_offset() const noexcept
    {
        return 48;
    }

    constexpr inline size_t _symbol_size_aligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _symbol_offset());
        size_t aligned_size = stored_size & 0x00FFFFFFFFFFFFFF;
        return aligned_size;
    }

    static size_t _symbol_calc_size_aligned(const std::string_view& value)
    {
        size_t contents_size = value.size() * 1;
        size_t unaligned_size = 8 + contents_size;
        return (unaligned_size + 7) & ~7;
    }

    constexpr inline size_t _symbol_size_unaligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _symbol_offset());
        size_t aligned_size = stored_size & 0x00FFFFFFFFFFFFFF;
        size_t aligned_diff = stored_size >> 56;
        return aligned_size - aligned_diff;
    }

    // Member: update_id [std::uint64_t]

    inline std::uint64_t update_id() const noexcept
    {
        return *reinterpret_cast<const std::uint64_t*>(buffer + _update_id_offset());
    }

    inline void update_id(const std::uint64_t value) noexcept
    {
        *reinterpret_cast<std::uint64_t*>(buffer + _update_id_offset()) = value;
    }

    constexpr inline size_t _update_id_offset() const noexcept
    {
        return _symbol_offset() + _symbol_size_aligned();
    }

    constexpr inline size_t _update_id_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _update_id_calc_size_aligned(const std::uint64_t& value)
    {
        return 8;
    }


    // Member: seq_num [std::uint64_t]

    inline std::uint64_t seq_num() const noexcept
    {
        return *reinterpret_cast<const std::uint64_t*>(buffer + _seq_num_offset());
    }

    inline void seq_num(const std::uint64_t value) noexcept
    {
        *reinterpret_cast<std::uint64_t*>(buffer + _seq_num_offset()) = value;
    }

    constexpr inline size_t _seq_num_offset() const noexcept
    {
        return _update_id_offset() + _update_id_size_aligned();
    }

    constexpr inline size_t _seq_num_size_aligned() const noexcept
    {
        return 8;
    }

    static size_t _seq_num_calc_size_aligned(const std::uint64_t& value)
    {
        return 8;
    }


    // Member: bid_prices [std::span<double>]

    inline std::span<double> bid_prices() const noexcept
    {
        size_t n_bytes = _bid_prices_size_unaligned() - 8;
        size_t count = n_bytes >> 3;
        auto ptr = reinterpret_cast<double*>(buffer + _bid_prices_offset() + 8);
        return std::span<double>(ptr, count);
    }

    inline void bid_prices(const std::span<double> value) noexcept
    {
        size_t offset = _bid_prices_offset();
        size_t contents_size = value.size() * 8;
        *reinterpret_cast<size_t*>(buffer + offset) = 8 + contents_size;
        auto dest_ptr = reinterpret_cast<std::byte*>(buffer + offset + 8);
        auto src_ptr = reinterpret_cast<const std::byte*>(value.data());
        std::copy(src_ptr, src_ptr + contents_size, dest_ptr);
    }

    constexpr inline size_t _bid_prices_offset() const noexcept
    {
        return _seq_num_offset() + _seq_num_size_aligned();
    }

    constexpr inline size_t _bid_prices_size_aligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _bid_prices_offset());
        return stored_size;
    }

    static size_t _bid_prices_calc_size_aligned(const std::span<double>& value)
    {
        size_t contents_size = value.size() * 8;
        return 8 + contents_size;
    }

    constexpr inline size_t _bid_prices_size_unaligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _bid_prices_offset());
        return stored_size;
    }

    // Member: bid_quantities [std::span<double>]

    inline std::span<double> bid_quantities() const noexcept
    {
        size_t n_bytes = _bid_quantities_size_unaligned() - 8;
        size_t count = n_bytes >> 3;
        auto ptr = reinterpret_cast<double*>(buffer + _bid_quantities_offset() + 8);
        return std::span<double>(ptr, count);
    }

    inline void bid_quantities(const std::span<double> value) noexcept
    {
        size_t offset = _bid_quantities_offset();
        size_t contents_size = value.size() * 8;
        *reinterpret_cast<size_t*>(buffer + offset) = 8 + contents_size;
        auto dest_ptr = reinterpret_cast<std::byte*>(buffer + offset + 8);
        auto src_ptr = reinterpret_cast<const std::byte*>(value.data());
        std::copy(src_ptr, src_ptr + contents_size, dest_ptr);
    }

    constexpr inline size_t _bid_quantities_offset() const noexcept
    {
        return _bid_prices_offset() + _bid_prices_size_aligned();
    }

    constexpr inline size_t _bid_quantities_size_aligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _bid_quantities_offset());
        return stored_size;
    }

    static size_t _bid_quantities_calc_size_aligned(const std::span<double>& value)
    {
        size_t contents_size = value.size() * 8;
        return 8 + contents_size;
    }

    constexpr inline size_t _bid_quantities_size_unaligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _bid_quantities_offset());
        return stored_size;
    }

    // Member: ask_prices [std::span<double>]

    inline std::span<double> ask_prices() const noexcept
    {
        size_t n_bytes = _ask_prices_size_unaligned() - 8;
        size_t count = n_bytes >> 3;
        auto ptr = reinterpret_cast<double*>(buffer + _ask_prices_offset() + 8);
        return std::span<double>(ptr, count);
    }

    inline void ask_prices(const std::span<double> value) noexcept
    {
        size_t offset = _ask_prices_offset();
        size_t contents_size = value.size() * 8;
        *reinterpret_cast<size_t*>(buffer + offset) = 8 + contents_size;
        auto dest_ptr = reinterpret_cast<std::byte*>(buffer + offset + 8);
        auto src_ptr = reinterpret_cast<const std::byte*>(value.data());
        std::copy(src_ptr, src_ptr + contents_size, dest_ptr);
    }

    constexpr inline size_t _ask_prices_offset() const noexcept
    {
        return _bid_quantities_offset() + _bid_quantities_size_aligned();
    }

    constexpr inline size_t _ask_prices_size_aligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _ask_prices_offset());
        return stored_size;
    }

    static size_t _ask_prices_calc_size_aligned(const std::span<double>& value)
    {
        size_t contents_size = value.size() * 8;
        return 8 + contents_size;
    }

    constexpr inline size_t _ask_prices_size_unaligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _ask_prices_offset());
        return stored_size;
    }

    // Member: ask_quantities [std::span<double>]

    inline std::span<double> ask_quantities() const noexcept
    {
        size_t n_bytes = _ask_quantities_size_unaligned() - 8;
        size_t count = n_bytes >> 3;
        auto ptr = reinterpret_cast<double*>(buffer + _ask_quantities_offset() + 8);
        return std::span<double>(ptr, count);
    }

    inline void ask_quantities(const std::span<double> value) noexcept
    {
        size_t offset = _ask_quantities_offset();
        size_t contents_size = value.size() * 8;
        *reinterpret_cast<size_t*>(buffer + offset) = 8 + contents_size;
        auto dest_ptr = reinterpret_cast<std::byte*>(buffer + offset + 8);
        auto src_ptr = reinterpret_cast<const std::byte*>(value.data());
        std::copy(src_ptr, src_ptr + contents_size, dest_ptr);
    }

    constexpr inline size_t _ask_quantities_offset() const noexcept
    {
        return _ask_prices_offset() + _ask_prices_size_aligned();
    }

    constexpr inline size_t _ask_quantities_size_aligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _ask_quantities_offset());
        return stored_size;
    }

    static size_t _ask_quantities_calc_size_aligned(const std::span<double>& value)
    {
        size_t contents_size = value.size() * 8;
        return 8 + contents_size;
    }

    constexpr inline size_t _ask_quantities_size_unaligned() const noexcept
    {
        size_t stored_size = *reinterpret_cast<size_t*>(buffer + _ask_quantities_offset());
        return stored_size;
    }

    // --------------------------------------------------------------------------------

    constexpr inline size_t fastbin_calc_binary_size() const noexcept
    {
        return _ask_quantities_offset() + _ask_quantities_size_aligned();
    }

    static size_t fastbin_calc_binary_size(
        const std::string_view& symbol,
        const std::span<double>& bid_prices,
        const std::span<double>& bid_quantities,
        const std::span<double>& ask_prices,
        const std::span<double>& ask_quantities
    )
    {
        return 64 + _symbol_calc_size_aligned(symbol) +
            _bid_prices_calc_size_aligned(bid_prices) +
            _bid_quantities_calc_size_aligned(bid_quantities) +
            _ask_prices_calc_size_aligned(ask_prices) +
            _ask_quantities_calc_size_aligned(ask_quantities);
    }

    /**
     * Returns the stored (aligned) binary size of the object.
     * This function should only be called after `fastbin_finalize()`.
     */
    constexpr inline size_t fastbin_binary_size() const noexcept
    {
        return *reinterpret_cast<size_t*>(buffer);
    }

    /**
     * Finalizes the object by writing the binary size to the beginning of its buffer.
     * After calling this function, the underlying buffer can be used for serialization.
     * To get the actual buffer size, call `fastbin_binary_size()`.
     */
    inline void fastbin_finalize() noexcept
    {
        *reinterpret_cast<size_t*>(buffer) = fastbin_calc_binary_size();
    }
};

// Type traits
template <>
struct is_variable_size<StreamOrderbook> : std::true_type {};

template <>
struct is_buffer_stored<StreamOrderbook> : std::true_type {};
}; // namespace my_models

inline std::ostream& operator<<(std::ostream& os, const my_models::StreamOrderbook& obj)
{
    os << "[my_models::StreamOrderbook size=" << obj.fastbin_binary_size() << " bytes]\n";
    os << "    server_time: " << obj.server_time() << "\n";
    os << "    recv_time: " << obj.recv_time() << "\n";
    os << "    cts: " << obj.cts() << "\n";
    os << "    type: " << obj.type() << "\n";
    os << "    depth: " << obj.depth() << "\n";
    os << "    symbol: " << std::string(obj.symbol()) << "\n";
    os << "    update_id: " << obj.update_id() << "\n";
    os << "    seq_num: " << obj.seq_num() << "\n";
    os << "    bid_prices: " << "[vector<float64> count=" << obj.bid_prices().size() << "]" << "\n";
    os << "    bid_quantities: " << "[vector<float64> count=" << obj.bid_quantities().size() << "]" << "\n";
    os << "    ask_prices: " << "[vector<float64> count=" << obj.ask_prices().size() << "]" << "\n";
    os << "    ask_quantities: " << "[vector<float64> count=" << obj.ask_quantities().size() << "]" << "\n";
    return os;
}
