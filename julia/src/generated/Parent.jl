import Base.show
import Base.finalizer
using StringViews

"""
Binary serializable data container generated by `fastbin`.

This container has variable size.
All setter methods starting from the first variable-sized member and afterwards MUST be called in order.

Members in order
================
- `field1::Int32`          (fixed)
- `child1::ChildFixed`     (fixed)
- `child2::ChildVar`       (variable)
- `str::StringView`        (variable)

The `fastbin_finalize!()` method MUST be called after all setter methods have been called.

It is the responsibility of the caller to ensure that the buffer is
large enough to hold all data.
"""
mutable struct Parent
    buffer::Ptr{UInt8}
    buffer_size::UInt64
    owns_buffer::Bool

    function Parent(buffer::Ptr{UInt8}, buffer_size::Integer, owns_buffer::Bool)
        owns_buffer || (@assert iszero(UInt(buffer) & 0x7) "Buffer not 8 byte aligned")
        new(buffer, UInt64(buffer_size), owns_buffer)
    end

    function Parent(buffer_size::Integer)
        buffer = reinterpret(Ptr{UInt8}, Base.Libc.malloc(buffer_size))
        obj = new(buffer, buffer_size, true)
        finalizer(_finalize!, obj)
    end
end

_finalize!(obj::Parent) = Base.Libc.free(obj.buffer)


# Member: field1::Int32
@inline function Base.getproperty(obj::Parent, ::Val{:field1})::Int32
    return unsafe_load(reinterpret(Ptr{Int32}, obj.buffer + _field1_offset(obj)))
end

@inline field1(obj::Parent)::Int32 = obj.field1

@inline function Base.setproperty!(obj::Parent, ::Val{:field1}, value::Int32)
    unsafe_store!(reinterpret(Ptr{Int32}, obj.buffer + _field1_offset(obj)), value)
end

@inline function field1!(obj::Parent, value::Int32)
    obj.field1 = value
end

@inline function _field1_offset(obj::Parent)::UInt64
    return 8
end

@inline function _field1_size_aligned(obj::Parent)::UInt64
    return 8
end

@inline function _field1_calc_size_aligned(::Type{Parent}, value::Int32)::UInt64
    return 8
end


# Member: child1::ChildFixed
@inline function Base.getproperty(obj::Parent, ::Val{:child1})::ChildFixed
    ptr::Ptr{UInt8} = obj.buffer + _child1_offset(obj)
    return ChildFixed(ptr, _child1_size_aligned(obj), false)
end

@inline child1(obj::Parent)::ChildFixed = obj.child1

@inline function Base.setproperty!(obj::Parent, ::Val{:child1}, value::ChildFixed)
    @assert fastbin_binary_size(value) > 0 "Cannot set member `child1`, parameter struct of type `ChildFixed` not finalized. Call fastbin_finalize!(obj) on struct after creation."
    offset::UInt64 = _child1_offset(obj)
    size::UInt64 = fastbin_binary_size(value)
    unsafe_copyto!(obj.buffer + offset, value.buffer, size)
end

@inline function child1!(obj::Parent, value::ChildFixed)
    obj.child1 = value
end

@inline function _child1_offset(obj::Parent)::UInt64
    return 16
end

@inline function _child1_size_aligned(obj::Parent)::UInt64
    return 16
end

@inline function _child1_calc_size_aligned(::Type{Parent}, value::ChildFixed)::UInt64
    return fastbin_binary_size(value)
end


# Member: child2::ChildVar
@inline function Base.getproperty(obj::Parent, ::Val{:child2})::ChildVar
    ptr::Ptr{UInt8} = obj.buffer + _child2_offset(obj)
    return ChildVar(ptr, _child2_size_aligned(obj), false)
end

@inline child2(obj::Parent)::ChildVar = obj.child2

@inline function Base.setproperty!(obj::Parent, ::Val{:child2}, value::ChildVar)
    @assert fastbin_binary_size(value) > 0 "Cannot set member `child2`, parameter struct of type `ChildVar` not finalized. Call fastbin_finalize!(obj) on struct after creation."
    offset::UInt64 = _child2_offset(obj)
    size::UInt64 = fastbin_binary_size(value)
    unsafe_copyto!(obj.buffer + offset, value.buffer, size)
end

@inline function child2!(obj::Parent, value::ChildVar)
    obj.child2 = value
end

@inline function _child2_offset(obj::Parent)::UInt64
    return 32
end

@inline function _child2_size_aligned(obj::Parent)::UInt64
    return unsafe_load(reinterpret(Ptr{UInt64}, obj.buffer + _child2_offset(obj)))
end

@inline function _child2_calc_size_aligned(::Type{Parent}, value::ChildVar)::UInt64
    return fastbin_binary_size(value)
end


# Member: str::StringView
@inline function Base.getproperty(obj::Parent, ::Val{:str})::StringView
    ptr::Ptr{UInt8} = reinterpret(Ptr{UInt8}, obj.buffer + _str_offset(obj))
    unaligned_size::UInt64 = _str_size_unaligned(obj)
    n_bytes::UInt64 = unaligned_size - 8
    count::UInt64 = n_bytes
    return StringView(unsafe_wrap(Vector{UInt8}, ptr + 8, count, own=false))
end

@inline str(obj::Parent)::StringView = obj.str

@inline function Base.setproperty!(obj::Parent, ::Val{:str}, value::AbstractString)
    offset::UInt64 = _str_offset(obj)
    contents_size::UInt64 = length(value) * 1
    unaligned_size::UInt64 = 8 + contents_size
    aligned_size::UInt64 = (unaligned_size + 7) & ~7
    aligned_diff::UInt64 = aligned_size - unaligned_size
    aligned_size_high::UInt64 = aligned_size | (aligned_diff << 56)
    unsafe_store!(reinterpret(Ptr{UInt64}, obj.buffer + offset), aligned_size_high)
    dest_ptr::Ptr{UInt8} = obj.buffer + offset + 8
    src_ptr::Ptr{UInt8} = reinterpret(Ptr{UInt8}, pointer(value))
    unsafe_copyto!(dest_ptr, src_ptr, contents_size)
end

@inline function str!(obj::Parent, value::AbstractString)
    obj.str = value
end

@inline function _str_offset(obj::Parent)::UInt64
    return _child2_offset(obj) + _child2_size_aligned(obj)
end

@inline function _str_size_aligned(obj::Parent)::UInt64
    stored_size::UInt64 = unsafe_load(reinterpret(Ptr{UInt64}, obj.buffer + _str_offset(obj)))
    aligned_size::UInt64 = stored_size & 0x00FFFFFFFFFFFFFF
    return aligned_size
end

@inline function _str_calc_size_aligned(::Type{Parent}, value::AbstractString)::UInt64
    contents_size::UInt64 = length(value) * 1
    unaligned_size::UInt64 = 8 + contents_size
    return (unaligned_size + 7) & ~7
end

@inline function _str_size_unaligned(obj::Parent)::UInt64
    stored_size::UInt64 = unsafe_load(reinterpret(Ptr{UInt64}, obj.buffer + _str_offset(obj)))
    aligned_diff::UInt64 = stored_size >> 56
    aligned_size::UInt64 = stored_size & 0x00FFFFFFFFFFFFFF
    return aligned_size - aligned_diff
end
@inline function Base.getproperty(obj::Parent, name::Symbol)
    name === :field1 && return getproperty(obj, Val(:field1))
    name === :child1 && return getproperty(obj, Val(:child1))
    name === :child2 && return getproperty(obj, Val(:child2))
    name === :str && return getproperty(obj, Val(:str))
    getfield(obj, name)
end

@inline function Base.setproperty!(obj::Parent, name::Symbol, value)
    name === :field1 && return setproperty!(obj, Val(:field1), value)
    name === :child1 && return setproperty!(obj, Val(:child1), value)
    name === :child2 && return setproperty!(obj, Val(:child2), value)
    name === :str && return setproperty!(obj, Val(:str), value)
    setfield!(obj, name, value)
end

# --------------------------------------------------------------------

@inline function fastbin_calc_binary_size(obj::Parent)::UInt64
    return _str_offset(obj) + _str_size_aligned(obj)
end

@inline function fastbin_calc_binary_size(::Type{Parent},
    child2::ChildVar,
    str::AbstractString
)
    return 32 +
        _child2_calc_size_aligned(Parent, child2) +
        _str_calc_size_aligned(Parent, str)
end

"""
Returns the stored (aligned) binary size of the object.
This function should only be called after `fastbin_finalize!(obj)`.
"""
@inline function fastbin_binary_size(obj::Parent)::UInt64
    return unsafe_load(reinterpret(Ptr{UInt64}, obj.buffer))
end

"""
Finalizes the object by writing the binary size to the beginning of its buffer.
After calling this function, the underlying buffer can be used for serialization.
To get the actual buffer size, call `fastbin_binary_size(obj)`.
"""
@inline function fastbin_finalize!(obj::Parent)
    unsafe_store!(reinterpret(Ptr{UInt64}, obj.buffer), fastbin_calc_binary_size(obj))
    nothing
end

function show(io::IO, obj::Parent)
    print(io, "[my_models::Parent]")
    print(io, "\n    field1: ")
    print(io, field1(obj))
    print(io, "\n    child1: ")
    show(io, child1(obj))
    print(io, "\n    child2: ")
    show(io, child2(obj))
    print(io, "\n    str: ")
    print(io, str(obj))
    println(io)
end
